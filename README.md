# Resume Fact-Checker: LLM + Z3

Прототип системы логического фактчекинга резюме. Извлекает утверждения из текста резюме с помощью LLM, формализует их в пропозициональную логику и проверяет на непротиворечивость с доменными правилами через Z3 SMT-солвер.

## Архитектура

```
Резюме (txt/pdf)
      |
      v
+--------------+
| LLM Extract  |  LLM: текст -> claims (label + formula + цитата)
+------+-------+
       v
+--------------+
| Lark Parse   |  Строки формул -> типизированный AST
+------+-------+
       v
+--------------+
|  Z3 Check    |  AST -> Z3 BoolRef, assert_and_track, SAT/UNSAT + unsat core
+------+-------+
       v
+--------------+
| LLM Analyze  |  Unsat core -> человекочитаемый анализ противоречий
+------+-------+
       v
   JSON-отчёт
```

## Структура проекта

```
test_project/
├── main.py                      # CLI, 4-стадийный пайплайн
├── config.py                    # Загрузка .env, API ключи
├── grammar/
│   └── logic.lark               # Lark-грамматика пропозициональной логики
├── parser/
│   ├── ast_nodes.py             # Dataclasses: Var, Pred, Not, And, Or, Implies, Bicond, Const
│   └── logic_parser.py          # Lark parser + LogicTransformer
├── prover/
│   └── z3_checker.py            # AST -> Z3, sat check, unsat core extraction
├── llm/
│   ├── extractor.py             # Резюме -> предикаты + формулы
│   ├── analyzer.py              # Unsat core -> анализ противоречий
│   └── prompts.py               # Системные промпты (на русском)
├── domain/
│   └── rules.py                 # Доменные правила (эвристики software engineering)
├── examples/
│   ├── resume_contradictory.txt # Резюме с противоречиями (iOS-разработчик)
│   └── resume_good.txt          # Согласованное резюме (C#-разработчик)
├── tests/
│   ├── test_parser.py           # 17 тестов
│   └── test_z3_checker.py       # 6 тестов
├── requirements.txt
├── .env                         # API ключи (не коммитить)
└── .env.example                 # Шаблон .env
```

## Установка

```bash
pip install -r requirements.txt
cp .env.example .env
# Вписать OPENAI_API_KEY в .env
```

## Запуск

```bash
# Резюме с противоречиями (ожидается UNSAT)
python main.py --resume examples/resume_contradictory.txt --verbose

# Согласованное резюме (ожидается SAT)
python main.py --resume examples/resume_good.txt --verbose

# Сохранить отчёт в файл
python main.py --resume examples/resume_contradictory.txt -o report.json

# PDF-резюме
python main.py --resume /path/to/resume.pdf
```

## Тесты

```bash
python -m pytest tests/ -v
```

## Примеры резюме

### resume_contradictory.txt (с противоречиями)

iOS-разработчик (Плавов Савелий). Содержит утверждения, которые вступают в конфликт с доменными правилами:

- *«сократил цикл запуска с 5 дней до 1 часа»* -- подразумевает `fastChanges`
- *«модульная архитектура с четкой слоистой декомпозицией»* -- подразумевает `qualityArch`
- *«сократил ошибки в production на 35%»* + *«crash-free rate 99.6%»* -- подразумевает `improvedStability`

Z3 находит UNSAT: быстрые изменения по доменным правилам ведут к упрощённой архитектуре и росту багов, что несовместимо с заявленным качеством и стабильностью.

### resume_good.txt (согласованное)

C#-разработчик (Шигапов Камиль). Утверждения не конфликтуют: стабильность, retry-механизмы, Outbox pattern, рефакторинг -- всё согласуется без логических напряжений. Z3 ожидаемо возвращает SAT.

## Грамматика логики

Приоритет операций (от низшего к высшему):

| Приоритет | Оператор | Значение |
|-----------|----------|----------|
| 1 | `<->` | Бикондиционал |
| 2 | `->` | Импликация (правоассоциативная) |
| 3 | `\|` | Дизъюнкция |
| 4 | `&` | Конъюнкция |
| 5 | `~` | Отрицание |

Атомы: `variable`, `predicate(args)`, `true`, `false`, `(formula)`.

## Доменные правила

| Метка | Формула | Смысл |
|-------|---------|-------|
| `rule_fast_bugs` | `fastChanges -> moreBugs` | Быстрые изменения ведут к росту багов |
| `rule_stability_less_changes` | `improvedStability -> lessChanges` | Стабильность подразумевает меньше изменений |
| `rule_bugs_changes_conflict` | `~(moreBugs & lessChanges)` | Больше багов и меньше изменений несовместимы |
| `rule_quality_design` | `qualityArch -> thoroughDesign` | Качественная архитектура требует тщательного проектирования |
| `rule_fast_shortcut` | `fastChanges -> shortcutArch` | Быстрые изменения ведут к упрощённой архитектуре |
| `rule_shortcut_thorough_conflict` | `~(shortcutArch & thoroughDesign)` | Упрощённая и тщательная архитектура несовместимы |
| `rule_sdui_concerns` | `sdui -> compatibility & rollback & monitoring` | SDUI влечёт проблемы совместимости |

## Доменный словарь и связывание LLM с Z3

Ключевая проблема архитектуры: LLM и Z3 — два независимых компонента, которые должны "говорить на одном языке". Доменные правила жёстко используют конкретные имена переменных (`fastChanges`, `qualityArch`), и LLM при извлечении утверждений из резюме **обязан использовать те же имена**, иначе Z3 не сможет связать утверждения с правилами.

### Что произойдёт без словаря

Без явного словаря LLM придумает свои имена переменных:
- `reducedCycle("5d","1h")` вместо `fastChanges`
- `modularArch` вместо `qualityArch`
- `crashFreeRate` вместо `improvedStability`

Z3 увидит два непересекающихся набора переменных — правила про `fastChanges`, утверждения про `reducedCycle`. Они никак не связаны, поэтому Z3 тривиально найдёт модель, где всё совместимо. Противоречие останется невидимым, и результат будет SAT даже на заведомо противоречивом резюме.

### Как работает словарь

Файл `domain/rules.py` содержит `DOMAIN_VOCABULARY` — словарь, где ключ — имя переменной, значение — описание на русском:

```python
DOMAIN_VOCABULARY = {
    "fastChanges": "Быстрые изменения, короткие циклы разработки, сокращение цикла запуска/релиза",
    "qualityArch": "Качественная архитектура, модульная архитектура, слоистая декомпозиция",
    ...
}
```

При построении промпта (`llm/prompts.py: build_extraction_prompt`) этот словарь вставляется в системное сообщение с инструкцией: *«Используй ИМЕННО эти доменные переменные, не придумывай свои»*. Это гарантирует, что формулы LLM и доменные правила ссылаются на одни и те же переменные → Z3 может обнаружить реальные противоречия.

### Разделение ответственности

| Компонент | Роль | Почему именно он |
|-----------|------|-----------------|
| **LLM** | Извлекает факты из текста | Хорош в NLU, плох в формальной логике |
| **Эксперт** | Пишет доменные правила и словарь | Знает предметную область |
| **Словарь** | Связывает LLM и правила | Контракт/онтология между компонентами |
| **Z3** | Проверяет непротиворечивость | Математически точен, без галлюцинаций |

### Альтернативные подходы (и почему они хуже)

- **LLM сама генерирует правила** — нестабильно (разный результат при каждом запуске), подвержено галлюцинациям, замкнутый круг (LLM сама решает, что считать противоречием).
- **Маппинг после извлечения** — дополнительный LLM-вызов для сопоставления `reducedCycle` ↔ `fastChanges`, ещё один источник ошибок.
- **Без доменных правил** — Z3 проверяет только внутреннюю непротиворечивость утверждений, без экспертных эвристик. Для большинства резюме результат будет тривиально SAT.

## Как это работает

1. **Извлечение (LLM)** -- LLM читает резюме и выдаёт JSON с утверждениями-формулами (`fastChanges`, `improvedStability`, `qualityArch` и т.д.)
2. **Парсинг (Lark)** -- каждая строка-формула парсится Earley-парсером в типизированный AST
3. **Проверка (Z3)** -- AST-формулы конвертируются в Z3 `BoolRef`, добавляются через `assert_and_track` (для маркировки). Если `UNSAT` -- извлекается минимальное ядро противоречия (unsat core)
4. **Анализ (LLM)** -- unsat core с метками передаётся LLM, который объясняет противоречия на русском языке и даёт рекомендации
